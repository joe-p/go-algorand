// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round uint64) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
